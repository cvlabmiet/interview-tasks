Кастомный main
--------------

Сразу перейдём к одному из *возможных* решений:

.. include:: custom_main.cpp
    :literal:
    :code: cpp

По умолчанию все программы линкуются статически с объектным файлом ``crt0.o``, который содержит настоящую точку входа в программу ``_start``.

Функция ``__libc_start_main`` вызывается кодом crt0 из динамически слинкованной библиотеки ``libc``.
Её работа заключается в инициализации программы, в частности в вызове конструкторов статических объектов, в том числе так называемых *статических конструкторов*.
Как правило, ``libc`` всегда линкуется динамически: т.е., одна библиотека в системе обслуживает все исполняемые программы.
Этим мы и воспользуемся.
Опишем все тонкости реализации программы по порядку.

Hiding символов при динамической линковке
    На этапе линковки программы важен порядок передаваемых динамических библиотек.
    При наличии одинаковых символов (в нашем случае это ``__libc_start_main``) во время исполнения программы будет вызван тот, который встретится раньше.
    Таким образом будет вызвана наша функция ``__libc_start_main``, а не аналогичная из библиотеки ``libc``.
    Заметим, что если библиотека будет линковаться статически, то этот фокус не будет работать.
    Существует способ, при котором можно попросить загрузчика динамических библиотек ``ld`` вернуть адрес следующего символа с таким же названием.
    Для этого служит флаг ``RTLD_NEXT``, с помощью которого можно получить все функции с одинаковыми именами в динамически слинкованных с нашей программой библиотеках.
    Поэтому мы просто сделаем необходимые нам действия, а потом вызовем настоящую ``__libc_start_main``.
    Чем-то анпоминает вызов базовой реализации при наследовании.

Mangling имён
    Язык C++ добавляет специальные префиксы и суффиксы к именам функций, чтобы поддерживать такие технологии, как перегрузку функций и пространства имён.
    Язык C же в свою очередь добавляет только префикс: дополнительный ``_`` к имени функции.
    Чтобы C++ правильно сформировал имя функции ``__libc_start_main`` необходимо сказать ему "делай как в языке C".
    Для этого мы добавляем модификатор ``extern "C"``.

Статические переменные
    Вектор с аргументами объявлен с модификатором ``static``.
    Это необходимо, так как некоторые реализации ``__libc_start_main`` не вызывают напрямую функцию ``main``, а оставляют это для следующего кода.
    Чтобы вектор не был очищен после выхода из функции, мы объявляем его статически.
    Почему внутри функции, а не в глобальной области?
    Чтобы не засорять глобальную область.
    Инкапсуляция, однако.

Три аргумента у ``main``
    Самые зоркие уже заметили, что у функции ``main`` три аргумента, а не два.
    Третий аргумент - это таблица с переменными окружения.
    Таблица с аргументами командной строки и переменными окружения лежат на самой макушке стека.
    Помещаются они туда самой операционной системой при загрузке исполняемого файла в память.

Размер одной переменной на стеке
    Воспользуемся ещё одним приёмом: при помещении аргумента функции в стек, её размер увеличиваеся до размера регистра.
    Размер регистра таков, что способен поместить в себе указатель на память (как минимум это ``std::size_t``).
    Таким образом, в первый аргумент можно положить адрес нашего вектора, а не ``int``.

Линеаризация цикла
------------------

Наверное, первое, что приходит на ум это

.. include:: multiloop_simple.cpp
    :literal:
    :code: cpp

Однако задача наша - *полностью* избавиться от вложенных циклов.
Приведённое же решение является попросту синтаксическим сахаром, которое во время компиляции разворачивается во вложенные циклы.

Да, в математике есть процедура, похожая на вложенные циклы.
И это - *декартово произведение*.
Будет, наверное, неожиданно, если мы скажем, что числа от 0 до 799 - это декартово произведение трёх отрезков:
:math:`{[0, 7]} \times {[0, 9]} \times {[0, 9]}`.
Каждая цифра соответствует своему циклу.
Младшая цифра - это самый вложенны цикл, который "бегает" быстрее всех.
Самая старшая цифра - это внешний цикл, самый "медлительный".

Если перевести числа из десятичной системы счисления в, скажем, двоичную, то количество цифр увеличится.
Но ведь таким образом увеличится и количество вложенных циклов!
А если перевести в 16-ричную систему, тогда цифр станет меньше, причём циклов тоже.
Вот оно и решение: чтобы линеаризовать циклы, необходимо использовать системы счисления с большим базисом.

Если с десятичной или любой *N*-ичной системой всё более менее понятно, то как быть, если базис каждой цифры произволен?
Для этого надо вспомнить, как обрабатываются картинки.
Как правило, под картинки выделяется единая область памяти.
Точка с координатами :math:`(x, y)` должна перейти в линейный адрес `i` этой памяти с помощью формулы:

.. math:: i = y \cdot width + x

где `width` - это ширина изображения.
Полное количество точек изображения определяется как :math:`width \cdot height`.

Куб определяется как набор картинок.
Линейный адрес `i` каждой точки куба - это порядковый номер картинки `z`, умноженный на размерность оси :math:`width \cdot height`, плюс номер строки `y`,
умноженный на размерность `width` и номер столбца `x`, размерность которого равна 1:

.. math:: i = z \cdot width \cdot height + y \cdot width + x

Для `N`-мерного куба:

.. math::
    i = x_{n-1} \prod_{k=0}^{N-1} W_k + x_{n-2} \prod_{k=0}^{N-1} W_k + \ldots + x_2 \cdot W_2 \cdot W_1 + x_1 \cdot W_1 \cdot W_0 + x_0 \cdot W_0

Таким образом, задача линеаризации циклов - это частный случай задачи понижения размерности.

Сколько чисел можно составить из 7 единиц и 3 нулей
---------------------------------------------------

Ответ заключается в использовании бинома Ньютона :math:`\binom{3}{10}`.

Представим, что все 10 цифр заняты единицами.
Мы будем заменять любые три единицы на символы `a`, `b` и `c`.
`a` может заменить одну из 10 единиц, при этом `b` остаётся 9 позиций, а `c` - всего 8.
В итоге получится, что разместить по 10 позициям `a`, `b` и `c` можно :math:`10 \cdot 9 \cdot 8` различными способами.
А теперь заменим `a`, `b` и `c` на символ 0.
Видим, что некоторые комбинации повторяются, так как все символы нуля одинаковые.
Сколько таких одинаковых комбинаций?

Для ответа на этот вопрос представим отдельно `a`, `b` и `c` по трём позициям.
Снова: `a` может занять 3 позиции, при этом `b` - 2, и `c` - 1.
Получаем, что комбинаций всего будет :math:`3 \cdot 2 \cdot 1 = 3!`.
